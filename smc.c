/* Autogenerated by /usr/bin/halcompile on Fri May 16 19:57:21 2025 -- do not edit */
#include "rtapi.h"
#ifdef RTAPI
#include "rtapi_app.h"
#endif
#include "rtapi_string.h"
#include "rtapi_errno.h"
#include "hal.h"
#include "rtapi_math64.h"

static int comp_id;

#ifdef MODULE_INFO
MODULE_INFO(linuxcnc, "component:smc:Follow input signal while obeying limits\nLimit the output signal to fall between min and max, limit its slew\nrate to less than maxv per second, and limit its second derivative to\nless than maxa per second squared.  When the signal is a position,\nthis means that the position, velocity, and acceleration are limited.");
MODULE_INFO(linuxcnc, "pin:in:float:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:enable:bit:0:in:1: out follows in, 0: out returns to 0 (always per constraints):1:None");
MODULE_INFO(linuxcnc, "pin:out:float:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:load:bit:0:in:When TRUE, immediately set \\fBout\\fB to \\fBin\\fR, ignoring maxv\nand maxa:0:None");
MODULE_INFO(linuxcnc, "pin:homing:bit:0:in::0:None");
MODULE_INFO(linuxcnc, "pin:home:float:0:in::0:None");
MODULE_INFO(linuxcnc, "pin:min_:float:0:in::-1e20:None");
MODULE_INFO(linuxcnc, "pin:max_:float:0:in::1e20:None");
MODULE_INFO(linuxcnc, "pin:maxv:float:0:in::1e20:None");
MODULE_INFO(linuxcnc, "pin:maxa:float:0:in:Max Acceleration. Note that the component becomes\nunstable with maxa greater than about 1e7 in a 1kHz thread:1e7:None");
MODULE_INFO(linuxcnc, "pin:smooth_steps:u32:0:in:Smooth out acceleration this many periods before reaching input or\nmax/min limit.  Higher values avoid oscillation, but will accelerate\nslightly more slowly.:2:None");
MODULE_INFO(linuxcnc, "funct:_:1:");
MODULE_INFO(linuxcnc, "license:GPL");
MODULE_INFO(linuxcnc, "author:John Kasunich");
MODULE_LICENSE("GPL");
#endif // MODULE_INFO


struct __comp_state {
    struct __comp_state *_next;
    hal_float_t *in;
    hal_bit_t *enable;
    hal_float_t *out;
    hal_bit_t *load;
    hal_bit_t *homing;
    hal_float_t *home;
    hal_float_t *min_;
    hal_float_t *max_;
    hal_float_t *maxv;
    hal_float_t *maxa;
    hal_u32_t *smooth_steps;
    double in_pos_old;

    double out_old;

    bool homing_old;

    bool braking;

    double braking_pos;

};
struct __comp_state *__comp_first_inst=0, *__comp_last_inst=0;

static void _(struct __comp_state *__comp_inst, long period);
static int __comp_get_data_size(void);
#undef TRUE
#define TRUE (1)
#undef FALSE
#define FALSE (0)
#undef true
#define true (1)
#undef false
#define false (0)

static int export(char *prefix, long extra_arg) {
    char buf[HAL_NAME_LEN + 1];
    int r = 0;
    int sz = sizeof(struct __comp_state) + __comp_get_data_size();
    struct __comp_state *inst = hal_malloc(sz);
    memset(inst, 0, sz);
    r = hal_pin_float_newf(HAL_IN, &(inst->in), comp_id,
        "%s.in", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->enable), comp_id,
        "%s.enable", prefix);
    if(r != 0) return r;
    *(inst->enable) = 1;
    r = hal_pin_float_newf(HAL_OUT, &(inst->out), comp_id,
        "%s.out", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->load), comp_id,
        "%s.load", prefix);
    if(r != 0) return r;
    *(inst->load) = 0;
    r = hal_pin_bit_newf(HAL_IN, &(inst->homing), comp_id,
        "%s.homing", prefix);
    if(r != 0) return r;
    *(inst->homing) = 0;
    r = hal_pin_float_newf(HAL_IN, &(inst->home), comp_id,
        "%s.home", prefix);
    if(r != 0) return r;
    *(inst->home) = 0;
    r = hal_pin_float_newf(HAL_IN, &(inst->min_), comp_id,
        "%s.min", prefix);
    if(r != 0) return r;
    *(inst->min_) = -1e20;
    r = hal_pin_float_newf(HAL_IN, &(inst->max_), comp_id,
        "%s.max", prefix);
    if(r != 0) return r;
    *(inst->max_) = 1e20;
    r = hal_pin_float_newf(HAL_IN, &(inst->maxv), comp_id,
        "%s.maxv", prefix);
    if(r != 0) return r;
    *(inst->maxv) = 1e20;
    r = hal_pin_float_newf(HAL_IN, &(inst->maxa), comp_id,
        "%s.maxa", prefix);
    if(r != 0) return r;
    *(inst->maxa) = 1e7;
    r = hal_pin_u32_newf(HAL_IN, &(inst->smooth_steps), comp_id,
        "%s.smooth-steps", prefix);
    if(r != 0) return r;
    *(inst->smooth_steps) = 2;
    inst->braking = 0;
    rtapi_snprintf(buf, sizeof(buf), "%s", prefix);
    r = hal_export_funct(buf, (void(*)(void *inst, long))_, inst, 1, 0, comp_id);
    if(r != 0) return r;
    if(__comp_last_inst) __comp_last_inst->_next = inst;
    __comp_last_inst = inst;
    if(!__comp_first_inst) __comp_first_inst = inst;
    return 0;
}
static int default_count=1, count=0;
RTAPI_MP_INT(count, "number of smc");
char *names = ""; // comma separated names
RTAPI_MP_STRING(names, "names of smc");
int rtapi_app_main(void) {
    int r = 0;
    int i;
    comp_id = hal_init("smc");
    if(comp_id < 0) return comp_id;
    if(count && names[0]) {
        rtapi_print_msg(RTAPI_MSG_ERR,"count= and names= are mutually exclusive\n");
        return -EINVAL;
    }
    if(!count && !names[0]) count = default_count;
    if(count) {
        for(i=0; i<count; i++) {
            char buf[HAL_NAME_LEN + 1];
            rtapi_snprintf(buf, sizeof(buf), "smc.%d", i);
            r = export(buf, i);
            if(r != 0) break;
       }
    } else {
        size_t i, j;
        int idx;
        char buf[HAL_NAME_LEN+1];
        const size_t length = strlen(names);
        for (i = j = idx = 0; i <= length; i++) {
            const char c = buf[j] = names[i];
            if ((c == ',') || (c == '\0')) {
                buf[j] = '\0';
                r = export(buf, idx);
                if(r != 0) {break;}
                idx++;
                j = 0;
            } else {
                if (++j == (sizeof(buf) / sizeof(buf[0]))) {
                    buf[j - 1] = '\0';
                    rtapi_print_msg(RTAPI_MSG_ERR,"names: \"%s\" too long\n", buf);
                    r = -EINVAL;
                    break;
                }
            }
        }
    }
    if(r) {
        hal_exit(comp_id);
    } else {
        hal_ready(comp_id);
    }
    return r;
}

void rtapi_app_exit(void) {
    hal_exit(comp_id);
}

#undef FUNCTION
#define FUNCTION(name) static void name(struct __comp_state *__comp_inst, long period)
#undef EXTRA_SETUP
#define EXTRA_SETUP() static int extra_setup(struct __comp_state *__comp_inst, char *prefix, long extra_arg)
#undef EXTRA_CLEANUP
#define EXTRA_CLEANUP() static void extra_cleanup(void)
#undef fperiod
#define fperiod (period * 1e-9)
#undef in
#define in (0+*__comp_inst->in)
#undef enable
#define enable (0+*__comp_inst->enable)
#undef out
#define out (*__comp_inst->out)
#undef load
#define load (0+*__comp_inst->load)
#undef homing
#define homing (0+*__comp_inst->homing)
#undef home
#define home (0+*__comp_inst->home)
#undef min_
#define min_ (0+*__comp_inst->min_)
#undef max_
#define max_ (0+*__comp_inst->max_)
#undef maxv
#define maxv (0+*__comp_inst->maxv)
#undef maxa
#define maxa (0+*__comp_inst->maxa)
#undef smooth_steps
#define smooth_steps (0+*__comp_inst->smooth_steps)
#undef in_pos_old
#define in_pos_old (__comp_inst->in_pos_old)
#undef out_old
#define out_old (__comp_inst->out_old)
#undef homing_old
#define homing_old (__comp_inst->homing_old)
#undef braking
#define braking (__comp_inst->braking)
#undef braking_pos
#define braking_pos (__comp_inst->braking_pos)


#line 32 "smc.comp"

#include "rtapi_math.h"

#define SET_NEXT_STATE(_out, _in)			\
    do {						\
	out_old = out;					\
	out = _out;					\
	in_pos_old = _in;				\
	return;						\
    } while (0)

#define VALID_NEXT(pos) ((pos) <= max_pos && (pos) >= min_pos)

// Distance = avg. velocity * time
#define S_GIVEN_VI_VF_T(vi,vf,t) (((vf) + (vi))/2 * (t))
// Time = chg. velocity / acceleration
#define T_GIVEN_VI_VF_A(vi,vf,a) (((vf) - (vi)) / (a))
// Final velocity = initial velocity + acceleration * time
#define VF_GIVEN_VI_A_T(vi,a,t) ((vi) + (a)*(t))
// A fudge amount for division errors
#define EPSILON 1e-9

#define BREAKING_S_GIVEN_V_A(vi,a) ((vi*vi)/(2*a))

FUNCTION(_) {
    double invalue;
    double in_pos_lim, in_vel;
    double min_vel, max_vel, min_pos, max_pos;
    double stop_pos_max, stop_pos_min;
    double stop_time_max, stop_time_min;
    double in_vel_time_max, in_vel_time_min;
    double out_pos_max, out_pos_min, in_pos_max, in_pos_min;
    double ach_pos_min, ach_pos_max;

    double out_vel = (out-out_old)/fperiod;
    double goal_pos_min, goal_pos_max, goal_pos_cur;
    double pos_diff, vel_diff, goal_pos_prev;
    double t, ti, a, v, s;

    //static bool inhomingvalue = inhoming;
    //static bool braking = false;

    if (enable)
    {
        braking = false;
        invalue = in;
    }
    else if (homing)
    {
        invalue = home;       
        braking_pos = home;
        in_pos_lim = fmin(max_, fmax(min_, invalue));
        SET_NEXT_STATE(in_pos_lim, in_pos_lim);
        return;
    }
    else
    {
        if (!braking)
        {
            if (out_vel)
            {
                if (BREAKING_S_GIVEN_V_A(out_vel,maxa) <= fabs(in - out))
                {
                    if(out_vel > 0)
                    {
                        braking_pos = out + BREAKING_S_GIVEN_V_A(out_vel,maxa);
                    }
                    else if(out_vel < 0)
                    {
                        braking_pos = out - BREAKING_S_GIVEN_V_A(out_vel,maxa);
                    }
                }
                else
                {
                    braking_pos = in;
                }
                braking = true;
            }
        }
        invalue = braking_pos;
    }

    homing_old = homing;

    if (load) {
	// Apply first order limit
	in_pos_lim = fmin(max_, fmax(min_, invalue));
	SET_NEXT_STATE(in_pos_lim, in_pos_lim);
	return;
    }

    // Principal of operation:
    // 
    // 1. Calculate shortest distance (at max acceleration) to
    //    stop (i.e. reach vel=0) and to match the input velocity
    // 2. Compare our projected positions and choose whether to worry
    //    about the max/min limits or to follow the input signal
    // 3. Adjust acceleration according to decision and return

    // 1.  Calculate distances and times to stop and match input velocity
    //
    // Input and output velocity
    in_vel = (invalue - in_pos_old) / fperiod;
    out_vel = (out - out_old) / fperiod;
    //
    // Most negative/positive velocity reachable in one period
    min_vel = fmax(VF_GIVEN_VI_A_T(out_vel, -maxa, fperiod), -maxv);
    max_vel = fmin(VF_GIVEN_VI_A_T(out_vel,  maxa, fperiod),  maxv);
    // Most negative/positive position reachable in one period
    // - cur. pos + (distance to reach min/max vel in one period)
    min_pos = out + min_vel * fperiod;
    max_pos = out + max_vel * fperiod;
    //
    // Shortest possible distance to stop
    // - time to decel to 0; start from previous period
    stop_time_max = fabs(T_GIVEN_VI_VF_A(max_vel, 0.0, maxa)) + fperiod;
    stop_time_min = fabs(T_GIVEN_VI_VF_A(min_vel, 0.0, maxa)) + fperiod;
    // - distance to stop from max_pos/min_pos
    stop_pos_max = out + S_GIVEN_VI_VF_T(max_vel, 0.0, stop_time_max);
    stop_pos_min = out + S_GIVEN_VI_VF_T(min_vel, 0.0, stop_time_min);
    //
    // Shortest possible distance to match input velocity
    // - time to match input velocity from this period; out runs 1 period behind
    in_vel_time_max = fabs(T_GIVEN_VI_VF_A(max_vel, in_vel, maxa)) - fperiod;
    in_vel_time_min = fabs(T_GIVEN_VI_VF_A(min_vel, in_vel, maxa)) - fperiod;
    // - output position after velocity match
    out_pos_max = max_pos + S_GIVEN_VI_VF_T(max_vel, in_vel, in_vel_time_max);
    out_pos_min = min_pos + S_GIVEN_VI_VF_T(min_vel, in_vel, in_vel_time_min);
    // - input position after velocity match
    in_pos_max = invalue + in_vel * in_vel_time_max;
    in_pos_min = invalue + in_vel * in_vel_time_min;

    // 2. Choose the current goal:  input signal, max limit or min limit
    // 
    // Min/Max limits:
    // - assume we're stopping at a limit by default
    vel_diff = -out_vel;
    ach_pos_min = stop_pos_min;
    ach_pos_max = stop_pos_max;
    // - are we headed to crash into a min/max limit?
    if (stop_pos_max > max_ + EPSILON && !VALID_NEXT(max_))
	goal_pos_min = goal_pos_max = goal_pos_cur = goal_pos_prev = max_;
    else if (stop_pos_min < min_ - EPSILON && !VALID_NEXT(min_))
	goal_pos_min = goal_pos_max = goal_pos_cur = goal_pos_prev = min_;
    // - if input is outside min/max limit but heading back in, is
    //   there time to keep heading toward the limit before we need to
    //   start running to meet the input signal?
    else if (invalue >= max_ && in_pos_max > out_pos_max)
	goal_pos_min = goal_pos_max = goal_pos_cur = goal_pos_prev = max_;
    else if (invalue <= min_ && in_pos_min < out_pos_min)
	goal_pos_min = goal_pos_max = goal_pos_cur = goal_pos_prev = min_;
    //
    // Input signal:
    // - no min/max constraints; chase the input signal
    else {
	goal_pos_min = in_pos_min;
	goal_pos_max = in_pos_max;
	goal_pos_cur = invalue;
	goal_pos_prev = in_pos_old;
	vel_diff = out_vel - in_vel;
	ach_pos_min = out_pos_min;
	ach_pos_max = out_pos_max;
    }

    // 3.  Adjust acceleration
    //
    // - Difference in position, last cycle
    pos_diff = out - goal_pos_prev;
    // - Time to reach goal position and velocity with uniform acceleration
    if (fabs(vel_diff) < EPSILON)
	t = 0;
    else
	t = pos_diff / ((vel_diff + 0) / 2); // t = dp / (avg dv)

    // - If current position and velocity are close enough to reach
    //   goal position in this period, and maintaining goal velocity
    //   in the next period doesn't violate acceleration constraints,
    //   pass the input straight to the output
    if (VALID_NEXT(goal_pos_cur) && fabs(t) <= fperiod)
	    SET_NEXT_STATE(goal_pos_cur, invalue);

    // - If no danger of overshoot, accel at max in direction of goal
    if (ach_pos_max < goal_pos_max + EPSILON)
	// Max pos. accel toward goal will still fall short
	SET_NEXT_STATE(max_pos, invalue);
    if (ach_pos_min > goal_pos_min - EPSILON)
	// Max neg. accel toward goal will still fall short
	SET_NEXT_STATE(min_pos, invalue);

    // - If close to reaching goal, try to grease a landing; always
    //   using max acceleration can result in oscillating around the
    //   goal but never quite getting things right to 'lock' onto it
    if (fabs(t) < fperiod * smooth_steps) {
	// - Round up the magnitude of time to an integral number of periods
#       define SIGN(n) (((n)>=0) ? 1 : -1)
	ti = (int)((t - EPSILON*SIGN(t)) / fperiod + SIGN(t)) * fperiod;
	// - Uniform acceleration to reach goal in time `ti`
	a = (vel_diff - 0) / ti;
	v = out_vel + a * fperiod;
	s = v * fperiod;
	// - Effect new position, within limits
	SET_NEXT_STATE(fmin(max_pos, fmax(min_pos, out + s)), invalue);
    }

    // - If moving toward goal and in danger of overshoot, accelerate
    //   at max in opposite direction of goal
    if (goal_pos_max + EPSILON < ach_pos_max && goal_pos_prev > out)
    	// Heading up from below
	SET_NEXT_STATE(min_pos, invalue);
    if (goal_pos_min - EPSILON > ach_pos_min && goal_pos_prev < out)
    	// Heading down from above
	SET_NEXT_STATE(max_pos, invalue);

    // - Shouldn't get here; coast
    SET_NEXT_STATE((min_pos+max_pos)/2, invalue);
}
static int __comp_get_data_size(void) { return 0; }
